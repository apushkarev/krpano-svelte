<krpano ui_reaction_delay="0.075"><action name="extend_krpano" type="Javascript" autorun="preinit"><![CDATA[ /* krpano.inlinefunctions.hyphenate = function(str) { return hyphenate(str); }; krpano.inlinefunctions.getrandomint = function(min, max) { return getRandomInt(min, max); }; krpano.inlinefunctions.elemexists = (e) => document.getElementById(e) != null; krpano.inlinefunctions.exists = (e) => e != null; */ ]]></action><this /><action name="get_this">copy(this, calc(_type + &#x27;[&#x27; + name + &#x27;]&#x27;));</action><action name="array_push" type="javascript"><![CDATA[ const [f, arrayName, arrayItemName] = args; krpano.set(`${arrayName}[${arrayItemName}].name`, arrayItemName); ]]></action><action name="" type="javascript" autorun="preinit"><![CDATA[ window.krpano = krpano; window._k = { a: () => krpano.actions, lgi: lName => krpano.layer.getItem(lName), lga: () => krpano.layer.getArray(), pgi: pName => krpano.plugin.getItem(pName), hgi: hName => krpano.hotspot.getItem(hName), hga: () => krpano.hotspot && krpano.hotspot.getArray(), sgi: sName => krpano.scene.getItem(sName), sga: () => krpano.scene && krpano.scene.getArray(), g: statement => krpano.get(statement), xs: () => krpano.xml.scene, sxs: () => krpano.scene.getItem(krpano.xml.scene), c: statement => krpano.call(statement), cwl: (lName, actions) => krpano.call(`callwith(layer[${lName}], ${actions})`), cwh: (hName, actions) => krpano.call(`callwith(hotspot[${lName}], ${action})`), i: () => krpano.inlinefunctions, s: () => krpano.settings, esi: () => krpano.embeddingsettings.initvars, esil: () => krpano.embeddingsettings.initvars._location, vh: () => parseFloat(krpano.view.hlookat), vv: () => parseFloat(krpano.view.vlookat), vf: () => parseFloat(krpano.view.fov), hfov: () => parseFloat(krpano.view.hfov), vfov: () => parseFloat(krpano.view.vfov), sl: () => krpano.actions.showlog(), isTrue: value => (typeof(value) == "string" && value == "true") || (typeof(value) == "boolean" && value) } ]]></action><action name="remove_array">if (%1, for(set(i, calc(%1.count - 1)), i GE 0, dec(i), %1.removearrayitem(get(i)); ); );</action><action name="new" type="javascript"><![CDATA[ const [f, className, name, ...params] = args; const classArray = className.split("|"); let constructorClass = ""; for (let i = 0; i < classArray.length; i++) { if (classArray[i] != "visible" && krpano.get(`style[${classArray[i]}].${classArray[i]}`)) { constructorClass = classArray[i]; } } if (caller) { krpano.call(` copy(parent, ${caller._type}[${caller.name}]); `); } krpano.call(`style[${constructorClass}].${constructorClass}(${name}, ${className}, ${params.join(", ")});`); ]]></action><action name="newhotspot">addhotspot(%1, this); this.loadstyle(%2);</action><action name="newlayer">addlayer(%1, this); this.loadstyle(%2);</action><action name="prompt" type="javascript"><![CDATA[ var code = prompt(args[1], args[2]); ]]></action><style name="Invisible_Content" visible="false" alpha="0" show_before="" show_precall="" show_after="" show_fast_precall="" hide_precall="" hide_before="" hide_after="" hide_fast_precall="" tween_duration_show="0.25" tween_duration_hide="0.25" target_alpha="1" tween_type="default" allow_showing="true" allow_hiding="true" is_showing="false" is_hiding="false" show_delay="0" hide_delay="0" show_call="" hide_call="" onloaded.add_event=" calc(show_call, name + &#x27;_show_call&#x27;); calc(hide_call, name + &#x27;_hide_call&#x27;); " show=" show_precall(); if (allow_showing, if (visible, if (is_hiding, stop_hiding(); show_smooth_routine(); ); , set(is_hiding, false); show_smooth_routine(); ); ); " show_smooth_routine=" /* нужно заново рассчитывать название шоукола, потому что */ /* событие onloaded может сработать позже, чем будет вызван метод show */ delayedcall(calc(name + &#x27;_show_call&#x27;), get(show_delay), set(visible, true); show_before(); set(is_showing, true); tween(alpha, get(target_alpha), get(tween_duration_show), get(tween_type), set(is_showing, false); show_after(); ); ); " hide=" hide_precall(); if (allow_hiding, if (visible, set(is_showing, false); hide_smooth_routine(); , if (is_showing, stop_showing(); hide_smooth_routine(); ); ); ); " hide_smooth_routine=" delayedcall(calc(name + &#x27;_hide_call&#x27;), get(hide_delay), hide_before(); set(is_hiding, true); tween(alpha, 0, get(tween_duration_hide), get(tween_type), set(visible, false); set(is_hiding, false); hide_after(); ); ); " stop_hiding=" set(is_hiding, false); stopdelayedcall(calc(name + &#x27;_hide_call&#x27;)); stoptween(alpha); " stop_showing=" set(is_showing, false); stopdelayedcall(calc(name + &#x27;_show_call&#x27;)); stoptween(alpha); " show_fast=" show_fast_precall(); if (allow_showing, stop_hiding(); show_before(); ifnot(visible, set(visible, true); copy(alpha, target_alpha); show_after(); , set(tween_in_progress, false); ); ); " hide_fast=" hide_fast_precall(); stop_showing(); if (visible AND allow_hiding, hide_before(); set(visible, false); set(alpha, 0); hide_after(); , set(tween_in_progress, false); ); " update_alpha=" if (visible AND alpha != target_alpha, tween(alpha, get(target_alpha), get(tween_duration), get(tween_type)); ); " /><style name="Visible" visible="true" alpha="1" /><console line_no="0" log=" if (%1 OR %1 == 0 OR %1 == false, trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: &#x27;, calc(%1)); , %1 == NaN, trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: %1 = NaN&#x27;); , %1 == null, trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: %1 = null&#x27;); , %1 == &#x27;&#x27;, trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: empty string&#x27;); ); inc(console.line_no); showlog(); " divider=" trace(&#x27;----------------------------------------------------&#x27;); " msg=" trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: &#x27;, %1); inc(console.line_no); showlog(); " var_name="" var=" set(var_name, %1); if ( %1 OR %1 == 0, trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: &#x27;, var_name, &#x27; = &#x27;, calc(%1)); , %1 === null, trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: &#x27;, var_name, &#x27; = null&#x27;); , %1 === NaN, trace(get(console.line_no), &#x27; | name: &#x27;, get(name), &#x27; :: &#x27;, var_name, &#x27; = NaN&#x27;); ); inc(console.line_no); showlog(); " /><style name="menu_button_background" style="Invisible_Content|Visible" keep="true" type="container" bgcapture="true" align="lefttop" x="20" y="20" width="42" height="42" bgroundedge="8" bgcolor="get:design.bg_color1" bgalpha="get:design.bg_alpha" bgborder="get:design.bg_border" onover=" tween(bgcolor, get(design.bg_color2), 0.1, default); " onout=" tween(bgcolor, get(design.bg_color1), 0.1, default); " ondown=" set(oy, 1); " onup=" set(oy, 0); " onclick=" delayedcall (get(ui_reaction_delay), onclick_actions(); ); " onover_actions="" onout_actions="" ondown_actions="" onup_ations="" onclick_actions=" if (menu.is_open, menu.close(); , menu.open(); ); " /><style name="menu_button_bar1" style="Button_Bar" align="lefttop" edge="left" x="10" y="14" width="18" set_position_close=" tween(rotate, 45, 0.25, default); tween(width, 20, 0.25, default); tween(x, 14, 0.25, default); " set_position_open=" tween(rotate, 0, 0.25, default); tween(width, 18, 0.25, default); tween(x, 10, 0.25, default); " /><style name="menu_button_bar2" style="Invisible_Content|Visible|Button_Bar" align="lefttop" edge="left" x="10" y="21" width="22" set_position_close=" hide(); " set_position_open=" show(); " /><style name="menu_button_bar3" style="Button_Bar" align="lefttop" edge="left" x="10" y="28" width="14" set_position_close=" tween(rotate, -45, 0.25, default); tween(width, 20, 0.25, default); tween(x, 14, 0.25, default); " set_position_open=" tween(rotate, 0, 0.25, default); tween(width, 14, 0.25, default); tween(x, 10, 0.25, default); " /><style name="menu_button_touch_area" type="container" bgcapture="true" align="center" width="100%" height="100%" onover=" callwith(layer[menu_button_background], onover_actions); " onout=" callwith(layer[menu_button_background], onout_actions); " ondown=" callwith(layer[menu_button_background], ondown_actions); " onup=" callwith(layer[menu_button_background], onup_ations); " onclick=" delayedcall (get(ui_reaction_delay), onclick_actions(); ); " onclick_actions=" if (menu.is_open, menu.close(); , menu.open(); ); " /><style name="menu" style="Invisible_Content" keep="true" type="container" align="lefttop" y="20" x="82" width="get:design.menu_width" height="100" bgroundedge="8" bgcolor="get:design.bg_color1" bgalpha="get:design.bg_alpha" bgborder="get:design.bg_border" height_open="0" hide_delay="0.125" set_opened_height=" set(height_open, %1); calc(height, %1 / 2); " show_before=" tween(height, get(height_open), 0.25, default); " hide_before=" tween(height, calc(height_open / 2), 0.25, default); " /><events name="menu_events" keep="true" onclick=" if (menu.is_open, menu.close(); ); " /><layer name="menu_button_background" style="menu_button_background"><layer name="menu_button_bar1" style="menu_button_bar1" /><layer name="menu_button_bar2" style="menu_button_bar2" /><layer name="menu_button_bar3" style="menu_button_bar3" /><layer name="menu_button_touch_area" style="menu_button_touch_area" /></layer><layer name="menu" style="menu" /><menu create_items=" for(set(i, 0), i LT menu_list.count, inc(i), calc(menu_list[get(i)].linkedMenuItem, menu_list[get(i)].name + &#x27;_item&#x27;); new(Invisible_Content|Menu_Item, get(menu_list[get(i)].linkedMenuItem), get(i) ); ); callwith(layer[menu], set_opened_height(calc( (menu_list.count + 1) * design.padding + menu_list.count * design.menu_item_height) ); ); " is_open="false" open=" set(menu.is_open, true); callwith(layer[menu], show); callwith(layer[menu_button_bar1], set_position_close); callwith(layer[menu_button_bar2], set_position_close); callwith(layer[menu_button_bar3], set_position_close); for(set(i, 0), i LT menu_list.count, inc(i), callwith(layer[get(menu_list[get(i)].linkedMenuItem)], show); ); " close=" set(menu.is_open, false); callwith(layer[menu], hide); callwith(layer[menu_button_bar1], set_position_open); callwith(layer[menu_button_bar2], set_position_open); callwith(layer[menu_button_bar3], set_position_open); for(set(i, 0), i LT menu_list.count, inc(i), callwith(layer[get(menu_list[get(i)].linkedMenuItem)], hide); ); " /><style name="Button_Bar" type="container" height="2" bgroundedge="1" bgcolor="calc:&#x27;0x&#x27; + design.text_color" bgalpha="1" /><style name="Menu_Item" keep="true" align="top" type="text" bgcolor="get:design.bg_color2" bgalpha="1" bgroundedge="5" width="calc:design.menu_width - 2 * design.padding" height="get:design.menu_item_height" parent="menu" linked_menu_list_item="" Menu_Item=" newlayer(%1, %2); set(this.linked_menu_list_item, %3); copy(this.html, menu_list[%3].caption); calc(this.y, (%3 + 1) * design.padding + %3 * design.menu_item_height); calc(this.show_delay, %3 * (0.25 / menu_list.count)); calc(this.hide_delay, (menu_list.count - 1 - %3) * 0.25 / menu_list.count); " onloaded=" js( setMenuItemCSS(get(name)) ); " onover=" tween(bgcolor, get(design.bg_color3), 0.1, default); " onout=" tween(bgcolor, get(design.bg_color2), 0.1, default); " ondown=" set(oy, 1); " onup=" set(oy, 0); " onclick=" delayedcall (get(ui_reaction_delay), onclick_actions(); ); " onclick_actions=" menu.close(); delayedcall (1, console.msg(&#x27;Происходят другие действия&#x27;); ); " /><action name="" type="javascript" autorun="preinit"><![CDATA[ window.setMenuItemCSS = lName => { const layer = krpano.layer.getItem(lName); layer.css = ` color: #${krpano.get(`design.text_color`)}; font-family: Open Sans; font-size: 20px; font-weight: 300; line-height: ${+krpano.get(`design.menu_item_height`) - 6}px; padding-left: ${krpano.get(`design.padding`)}px; `; }; ]]></action><action name="startup0" autorun="preinit">/* Надо для работы тура */ /* делает нормальную консоль */ if (device.desktop, js( setKRPanoConsole() ); ); /* парсит урл */ js( readURL() ); delayedcall (0.5, callwith(layer[menu_button_background], show); ); menu.create_items();</action></krpano>